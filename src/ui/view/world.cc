/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright Â© 2015-2016, blue.chu
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of blue.chu nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL blue.chu BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

#include "./world.h"
#include "./entity.h"

namespace qk {
	// Geometric epsilon for float comparisons
	constexpr float GEOM_EPS = 1e-6f;

	static float frandf(float min, float max) {
		constexpr float randMaxInv = 1.0f / float(RAND_MAX);
		return min + rand() * randMaxInv * (max - min);
	}

	void onUIEvent(cUIEventName& name, Agent* agent, UIEvent *evt) {
		struct CbCore: CallbackCore<Object> {
			CbCore(cUIEventName& name, UIEvent* evt) : name(name), evt(evt) {}
			void call(Data& e) { static_cast<Agent*>(e.data)->trigger(name, **evt); }
			Sp<UIEvent> evt;
			cUIEventName& name;
		};
		auto core = new CbCore(name, evt);
		agent->preRender().post(Cb(core), agent);
	}

	template<class T, typename... Args>
	static void onEvent(cUIEventName& name, Agent* agent, Args... args) {
		onUIEvent(name, agent, new T(agent, args...));
	}

	static void onDiscoveryAgent(Agent* agent, Agent* other, Vec2 mtv, uint32_t level, bool entering) {
		Agent* otherPtr = static_cast<Agent*>(other->tryRetain_rt());
		if (!otherPtr) // check agent validity
			return; // other agent is being destroyed
		struct Wrap { Sp<Agent> other; Vec2 mtv; uint32_t id; uint32_t level; bool entering; };
		struct CbCore: CallbackCore<Object> {
			void call(Data& e) {
				auto agent = static_cast<Agent*>(e.data);
				auto evt = new DiscoveryAgentEvent(agent, w.other.get(), w.mtv, w.id, w.level, w.entering);
				Sp<DiscoveryAgentEvent> h(evt);
				agent->trigger(UIEvent_DiscoveryAgent, **h);
			}
			Wrap w;
		};
		auto core = new CbCore;
		core->w = { Sp<Agent>::lazy(otherPtr), mtv, uint32_t(uintptr_t(other)), level, entering };
		agent->preRender().post(Cb(core), agent); // post to main thread
	}

	World::World()
		: _playing(false)
		, _subSteps(1), _timeScale(1.0f)
		, _predictionTime(0.1f)
		, _discoveryThresholdBuffer(5.0f)
		, _waypointRadius(0.0f) {
	}

	View* World::init(Window *win) {
		View::init(win);
		set_free(true);
		return this;
	}

	void World::set_playing(bool value) {
		if (_playing != value) {
			_playing = value;
			if (_playing) {
				preRender().addtask(this); // add task
			} else {
				preRender().untask(this); // remove task
			}
		}
	}

	void World::set_discoveryThresholdBuffer(float value) {
		_discoveryThresholdBuffer = Float32::clamp(value, 0.0f, 100.0f);
	}

	void World::set_subSteps(int value) {
		_subSteps = Int32::clamp(value, 1, 5);
	}

	void World::set_timeScale(float value) {
		_timeScale = Float32::clamp(value, 0.1f, 10.0f);
	}

	void World::set_predictionTime(float value) {
		_predictionTime = Float32::clamp(value, 0.05f, 2.0f);
	}

	void World::set_waypointRadius(float value) {
		_waypointRadius = Float32::max(value, 0.0f);
	}

	ViewType World::viewType() const {
		return kWorld_ViewType;
	}

	void World::onActivate() {
		if (level() == 0 || !_playing) {
			preRender().untask(this); // remove task
		} else {
			preRender().addtask(this); // add task
		}
	}

	void World::onChildLayoutChange(View* child, uint32_t mark) {
		auto other = child->asAgent();
		if (other && (!child->parent() || !child->visible())) { // removed from world or invisible
			auto v = first();
			while (v) {
				auto agent = v->asAgent();
				if (agent && other != agent) {
					// Remove from discovery set if no longer visible
					if (agent->_discoverys_rt.erase(other)) { // erase success
						onDiscoveryAgent(agent, other, Vec2(), 0xffffffff, false); // lose discovery, remove agent
					}
					if (agent->_followTarget == other) {
						agent->_following = false;
						agent->_followTarget = nullptr; // cancel follow target
						// notify cancel follow target
						onEvent<FollowStateEvent>(UIEvent_FollowStateChange, agent, FollowStateEvent::kCancel);
					}
				}
				v = v->next();
			}
		}
		View::onChildLayoutChange(child, mark);
	}

	bool World::run_task(int64_t time, int64_t delta) {
		// World per-frame update logic can be added here
		Array<Agent*> agents, follows;
		Array<Entity*> entities;
		auto v = first();
		while (v) {
			auto entity = v->asEntity();
			// only process visible entities
			if (entity && entity->_circleBounds.radius != 0.0f && entity->visible()) {
				auto agent = entity->asAgent();
				if (agent && agent->_active && agent->_velocityMax) {
					// Skip line segment agents for movement
					if (agent->_bounds.type != Entity::kLineSegment) {
						if (agent->_followTarget) {
							follows.push(agent); // process follow targets later
						} else {
							agents.push(agent); // normal agent
						}
					}
				}
				if (entity->_isObstacle)
					entities.push(entity);
			}
			v = v->next();
		}

		if (agents.isNull() && follows.isNull()) {
			return false; // no active agents
		}

		float nsTime = 1.0f / 1e6f; // convert ns to seconds
		float timeFloat = time * nsTime; // convert to seconds
		auto deltaTime = delta * nsTime * _timeScale; // convert to seconds

		// Update normal agents
		for (auto agent : agents) {
			updateAgentWithMovement(agent, entities, timeFloat, deltaTime);
		}
		// Update follow agents
		for (auto agent : follows) {
			updateAgentWithFollow(agent, entities, timeFloat, deltaTime);
		}

		return false;
	}

	void World::updateAgentWithMovement(Agent* agent, cArray<Entity*>& obs, float time, float delta) {
		auto waypoints = agent->_waypoints.load(); // waypoints array
		auto current = agent->_currentWaypoint; // current waypoint index
		if (waypoints) {
			while (agent->_active && delta > 0.0f) { // still active
				// Move towards current waypoint
				delta = updateAgentWithAvoidance(agent, obs, agent->_avoidanceFactor, time, delta);
				if (delta == 0.0f) {
					auto velocitySq = agent->_velocity.lengthSq();
					auto velocityMaxSq = agent->_velocityMax * agent->_velocityMax; // for optimization
					if (velocitySq / velocityMaxSq < 0.3f) {
						// Stopped moving due to avoidance
						// Check if the target has been approximately reached
						auto buffer = agent->_circleBounds.radius + _waypointRadius;
						auto toTarget = agent->_target - agent->_translate;
						auto toTargetLen = toTarget.length();
						if (toTargetLen <= buffer)
							goto tag1; // consider reached, advance to next waypoint
					}
					break; // no remaining, done for this frame
				}
			 tag1:
				if (current >= waypoints->ptsLen()) break;
				if (agent->_target != waypoints->atPt(current)) {
					// Set initial target waypoint if target changed
					agent->_target = waypoints->atPt(current);
					continue; // continue moving towards target
				}
				auto target = agent->_target; // current target waypoint
				current++; // next waypoint index
				agent->_currentWaypoint = current; // advance to next waypoint
				auto isNext = current < waypoints->ptsLen();
				// vector to next waypoint
				auto toNext = isNext ? waypoints->atPt(current) - target : Vec2();
				// Reached current waypoint event
				onEvent<ArrivePositionEvent>(UIEvent_ReachWaypoint, agent, target, toNext, current);
				if (isNext) {
					agent->_target = waypoints->atPt(current); // set new target
				} else {
					agent->_active = false; // reached final waypoint, stop
					onEvent<ArrivePositionEvent>(UIEvent_ArriveDestination, agent, target, Vec2(), 0);
					break;
				}
			}
		} else if (agent->_active) {
			delta = updateAgentWithAvoidance(agent, obs, agent->_avoidanceFactor, time, delta);
			if (delta != 0.0f) { // Already at target, ended movement
				agent->_active = false;
				onEvent<ArrivePositionEvent>(UIEvent_ArriveDestination, agent, agent->_target, Vec2(), 0);
			}
		}
	}

	void World::updateAgentWithFollow(Agent* agent, cArray<Entity*>& obs, float time, float delta) {
		auto target = agent->_followTarget.load();
		if (!target || !agent->_active)
			return;
		if (target->_bounds.type == Entity::kLineSegment)
			return;
		Qk_ASSERT(agent->_bounds.type != Entity::kLineSegment);

		Vec2 pos = agent->_translate; // current position
		MTV mtv; // minimum translation vector for avoidance
		Vec2 mtvVec;
		float avoidance = agent->_avoidanceFactor;

		if (agent->test_entity_vs_entity(target, &mtv, &mtvVec, true)) {
			agent->_target = pos + mtvVec; // set target to avoid collision
		} else {
			Qk_ASSERT(mtv.overlap >= 0.0f);
			float mtvLen = mtv.overlap; // distance to target
			float minBuf = mtvLen - agent->_followMinDistance;
			float maxBuf = mtvLen - agent->_followMaxDistance;
			//float maxBufHalf = maxBuf + (agent->_followMaxDistance - agent->_followMinDistance) * 0.5f;
			if (minBuf < GEOM_EPS) {
				agent->_target = pos + mtv.axis * minBuf; // too close, move away
			}
			else if (maxBuf > GEOM_EPS && (agent->_following || maxBuf > agent->_safetyBuffer)) {
				float radius = target->_circleBounds.radius + agent->_followMaxDistance;
				float w = fabsf(std::min(mtv.overlap / radius - 1.0f, 1.0f)); // 0~1
				// When a gravitational range is set close, the gravitational force increases,
				// But as it approaches the core, the gravity gradually weakens,
				// causing a situation where people from the outer circle are more likely to squeeze into the inner circle
				avoidance *= (0.5f + w * 0.5f);
				agent->_target = pos + mtv.axis * (maxBuf + 0.1f/*EPSILON*/); // too far, move closer
			} else {
				// Already at follow distance
				if (agent->_following) {
					Qk_DLog("FollowStateEvent::kStop");
					agent->_following = false;
					onEvent<FollowStateEvent>(UIEvent_FollowStateChange, agent, FollowStateEvent::kStop);
				}
				return;
			}
		}

		if (!agent->_following) {
			Qk_DLog("FollowStateEvent::kStart");
			agent->_following = true;
			onEvent<FollowStateEvent>(UIEvent_FollowStateChange, agent, FollowStateEvent::kStart);
		}

		updateAgentWithAvoidance(agent, obs, avoidance, time, delta);
	} 

	/**
	 * discovery event processing
	 */
	void World::handleDiscoveryEvents(Agent* agent, Agent* other, MTV mtv) {
		// compute discovery distance squared
		auto buffer = _discoveryThresholdBuffer; // buffer distance to prevent flickering
		auto dds = agent->_discoveryDistances.load();
		auto mtvLen = mtv.overlap;
		auto level = dds->length();
		for (int i = level - 1; i >= 0; i--) {
			if (mtvLen < dds->at(i)) {
				level = i; // found level
			} else
				break;
		}
		Vec2 mtvVec = mtv.axis * mtv.overlap;
		// process discovery levels
		if (level < dds->length()) { // within some level
			uint32_t *lastLevel;
			if (agent->_discoverys_rt.get(other, lastLevel)) { // found
				if (level > *lastLevel) { // leave
					if (mtvLen > dds->at(*lastLevel) + buffer) { // buffered leave
						*lastLevel = level; // update level
						onDiscoveryAgent(agent, other, mtvVec, level, false); // leave
					}
				} else if (level < *lastLevel) { // entering
					if (mtvLen < dds->at(*lastLevel) - buffer) {
						*lastLevel = level; // update level
						onDiscoveryAgent(agent, other, mtvVec, level, true); // entering
					}
				}
			} else { // new discovery
				agent->_discoverys_rt.set(other, level);
				onDiscoveryAgent(agent, other, mtvVec, level, true); // entering
			}
		} else { // out of all levels
			if (agent->_discoverys_rt.erase(other)) { // erase success
				onDiscoveryAgent(agent, other, mtvVec, 0xffffffff, false); // lose discovery
			}
		}
	}

	// ------------------------ å±é¨é¿è®©åæï¼ç»å SAT MTVï¼å³æ¶ï¼ä¸ é¢æµ (T) ------------------------
	Vec2 World::computeAvoidanceForAgent(Agent *agent, cArray<Entity*>& obs, Vec2 dirToTarget) {
		bool isPoly = agent->_bounds.type == Entity::kPolygon;
		auto &pts = agent->ptsOfBounds();
		Circle &circ = agent->_circleBounds;
		Vec2 pos = circ.center;
		Vec2 dir = (agent->_velocity.lengthSq() > GEOM_EPS) ? agent->_velocity.normalized() : dirToTarget;
		Vec2 avoidanceTotal; // total avoidance vector
		float maxDist = agent->_velocityMax * _predictionTime;

		#define USE_tangent 1

		for (auto o : obs) {
			if (o == agent) continue; // skip self
			// select safety buffer
			float safetyBuf = agent->_safetyBuffer;
			bool isFollowingTarget = agent->_followTarget == o;
			if (isFollowingTarget) // following target
				safetyBuf = agent->_followMinDistance; // use min follow distance as buffer
			MTV mtv; // avoidance vector for this obstacle

			if (o->_bounds.type == Entity::kDefault || o->_bounds.type == Entity::kCircle) { // 1) å¤çåå½¢éç¢
				Circle circB = o->_circleBounds;
				if (isPoly ? test_polygon_vs_polygon(pts, o->ptsOfBounds(), &mtv):
						test_circle_vs_circle(circ, circB, &mtv)) {
					avoidanceTotal += mtv.axis * mtv.overlap; // æ¨å¼ä¼åï¼ææ·±åº¦å æ
				} else if (!isFollowingTarget) { // å¦ææ¯è·éç®æ ä¸éè¦é¢æµé¿è®©ï¼åºè¯¥ç´æ¥é è¿
					float d = isPoly ?
						predict_forward_distance_circ_to_poly(circB, -dir, pts, safetyBuf, &pos):
						predict_forward_distance_circ_to_circ(circ, dir, circB, safetyBuf);
					if (d < maxDist) {
						// è¿ç¦»éç¢ä¸­å¿åçº¿æ¹åé¿è®©
						auto away = (pos - circB.center).normalized();
						#if USE_tangent
							away = away.det(dirToTarget) < GEOM_EPS ? away.rotate90z() : away.rotate270z();
						#endif
						avoidanceTotal += away * (1.0f + (maxDist - d) / maxDist);
					}
				}
			}
			else if (o->_bounds.type == Entity::kPolygon) { // 2) å¤çå¤è¾¹å½¢éç¢ï¼ä½¿ç¨ SAT ç²¾ç¡®åç¦»åéï¼
				auto &ploy = o->ptsOfBounds();
				if (test_polygon_vs_polygon(pts, ploy, &mtv)) {
					avoidanceTotal += mtv.axis * mtv.overlap; // ç¸äº¤ï¼MTV å·²è¿å
				} else if (!isFollowingTarget) { // å¦ææ¯è·éç®æ ä¸éè¦é¢æµé¿è®©
					Vec2 cent; // è´¨å¿
					float d = isPoly ?
						predict_forward_distance_poly_to_poly(pts, dir, ploy, safetyBuf, &pos, &cent) :
						predict_forward_distance_circ_to_poly(circ, dir, ploy, safetyBuf, &cent);
					if (d < maxDist) {
						// è¿ç¦»éç¢ä¸­å¿åçº¿æ¹åé¿è®©
						Vec2 away = (pos - cent).normalized();
						#if USE_tangent
							away = away.det(dirToTarget) < GEOM_EPS ? away.rotate90z() : away.rotate270z();
						#endif
						avoidanceTotal += away * (1.0f + (maxDist - d) / maxDist);
					}
				}
			} else { // 3) å¤ççº¿æ®µéç¢
				auto halfWidth = o->_bounds.halfThickness;
				auto &pts = o->ptsOfBounds();
				auto a = pts.at(0);
				for (int i = 1; i < pts.length(); ++i) {
					auto b = pts.at(i);
					LineSegment seg{a, b, halfWidth};
					if (isPoly ? test_poly_vs_line_segment(pts, seg, &mtv) :
							test_circle_vs_line_segment(circ, seg, &mtv)) {
						avoidanceTotal += mtv.axis * mtv.overlap; // æ¨å¼ä¼åï¼ææ·±åº¦å æ
					} else {
						// é¢æµï¼å¦æå¨ T æ¶é´åå¯è½ä¼å°è¾¾å¢ä½
						float d = isPoly ?
							predict_forward_distance_poly_to_seg(pts, dir, seg, safetyBuf, &pos) :
							predict_forward_distance_circ_to_seg_fast(circ, dir, seg, safetyBuf);
						if (d < maxDist) {
							// å°é¿è®©æåè®¾ç½®ä¸ºè¿ç¦»çº¿æ®µä¸­å¿åçº¿çæ¹å
							Vec2 cent = (seg.a + seg.b) * 0.5f;
							Vec2 away = (pos - cent).normalized(); // è¿ç¦»æ¹å
							#if USE_tangent
								away = away.det(dirToTarget) < GEOM_EPS ? away.rotate90z() : away.rotate270z();
							#endif
							avoidanceTotal += away * (1.0f + (maxDist - d) / maxDist); // å æé¿è®© 1->2 away
						}
					}
					a = b;
				}
			}
		}

		return avoidanceTotal; // è¿åæ»é¿è®©åé
	}

	// ------------------------ æ´æ°åä¸ª agent çä¸»å½æ°ï¼åå«å­æ­¥è¿­ä»£ï¼
	float World::updateAgentWithAvoidance(Agent* agent, cArray<Entity*>& obs, float avoidFactor, float time, float deltaTime) {
		Qk_ASSERT(agent->_velocityMax > 0.0f); // must have max velocity
		Qk_ASSERT(agent->_bounds.type != Entity::kLineSegment); // line segment agent does not move

		bool isPoly = agent->_bounds.type == Entity::kPolygon;
		Circle &circ = agent->_circleBounds;
		Vec2 pos = agent->_translate; // current position
		// Vec2 pos = circ.center; // current position
		Vec2 toTarget = agent->_target - pos;

		if (toTarget.lengthSq() < GEOM_EPS) {
			// Already at target
			return deltaTime; // overflow all time
		}

		if (time - agent->_lastUpdateTime > 1.0f) { // 1 second without update
			// If last update was long ago, reset velocity to avoid sudden jumps
			agent->_velocity = {}; // reset velocity
		}
		agent->_lastUpdateTime = time;

		// precompute polygon points at current position
		auto* pts = isPoly ? &agent->ptsOfBounds() : nullptr;
		// load discovery distances
		auto dds = agent->_discoveryDistances.load();

		// sub-step integration
		float stepDt = deltaTime / std::max(1, _subSteps);
		for (int step = 0; step < _subSteps; ++step) {
			Vec2 dirToTarget = toTarget.normalized(); // recompute each step
			// recompute avoidance (could be expensive; can be throttled)
			Vec2 avoidance = computeAvoidanceForAgent(agent, obs, dirToTarget);

			Vec2 newDir;
			// å¦æ avoidance å ä¹ä¸º 0ï¼åä¸å¹²é¢
			if (avoidance.lengthSq() < GEOM_EPS) {
				newDir = dirToTarget; // no avoidance
			} else {
				// æ»å¨ä¼åï¼å°è¯åæç®æ ä¸é¿è®©
				Vec2 aDir = avoidance.normalized();
				float oppose = aDir.dot(dirToTarget); // [-1,1]
				// æ£æ¥æ¯å¦å ä¹äºç¸æµæ¶ï¼æ­£é¢ç¡¬é¡¶ï¼åæ³çº¿ï¼æ²¿éç¢è¾¹æ»å¨ï¼
				if (oppose < GEOM_EPS - 1.0f) {
					// å¤æ­ dir ä¸ aDir çç¸å¯¹æåï¼éè¿åç§¯ç¬¦å·ï¼
					newDir = aDir.det(dirToTarget) < GEOM_EPS ? aDir.rotate90z() : aDir.rotate270z();
				} else {
					// æ ¹æ®å¯¹æç¨åº¦ï¼èªå¨è°ä½é¿è®©æ¯é
					// float weight = 0.8f + (-oppose) * 0.3f; // weight é¿è®©æé ~0.5->1.1
					float weight = 0.8f;
					Vec2 sum = dirToTarget + aDir * weight;
					newDir = sum.normalized();
				}
			}

			// limit velocity change
			Vec2 lastVelocity = agent->_velocity;
			// First order low-pass filtering, smooth velocity change
			auto velocity = lastVelocity * 0.85f + newDir * agent->_velocityMax * 0.15f;
			//auto velocity = newDir * agent->_velocityMax;
			float vLen = velocity.length();
			float maxV = agent->_velocityMax;
			if (vLen > maxV) // clamp to max velocity
				velocity *= maxV / vLen;
			agent->_velocity = velocity; // update agent velocity

			// report direction change event
			Vec2 velocityDir = velocity.normalized();
			if (velocityDir.dot(agent->_lastReportDir) < 0.9f) { // direction changed
				agent->_lastReportDir = velocityDir;
				onEvent<AgentStateChangeEvent>(UIEvent_DirectionChange, agent);
			}

			// tentative move
			Vec2 move = velocity * stepDt;
			if (pts) { // precompute polygon points at new position
				for (auto& pt : *pts) pt += move;
			}
			circ.center += move; // precompute circle at new position

			bool collided = false;
			Vec2 totalMTV;
			for (auto o : obs) {
				if (o == agent) continue; // skip self
				MTV mtv;
				auto other = o->asAgent();
				bool isEvent = dds && other; // only agents have discovery events
				if (agent->test_entity_vs_entity(o, &mtv, &totalMTV, isEvent)) {
					collided = true;
				}
				if (isEvent) { // handle discovery events
					handleDiscoveryEvents(agent, other, mtv);
				}
			}

			float movedLenSq = move.lengthSq();
			float toTargetLenSq = toTarget.lengthSq();

			if (collided) {
				agent->_velocity *= agent->_avoidanceVelocityFactor; // reduce velocity on collision
				// apply total MTV to move out of collision
				float overlap = totalMTV.length() + 1e-3f; // ç©¿éæ·±åº¦ææå°åç¦»è·ç¦»
				float factor = avoidFactor;
				float near = std::min(sqrtf(toTargetLenSq) / circ.radius, 1.0f);
				factor *= (0.8f + near * 0.2f); // reduce avoid factor when near target
				auto avoidance = totalMTV.normalized() * (overlap * factor);
				// precompute polygon points for next step
				if (pts && step < _subSteps - 1) {
					for (auto &pt: *pts) pt += avoidance;
				}
				move += avoidance;
				circ.center += avoidance; // update circle center
			}

			// check if reached target
			if (movedLenSq >= toTargetLenSq) {
				float scalar = sqrtf(toTargetLenSq) / sqrtf(movedLenSq); // 0-1 scale
				Vec2 finalMove = move * scalar; // scale move to exactly
				float lenSq = (toTarget - finalMove).lengthSq();
				if (lenSq < 1) {
					// reached target this step
					agent->set_translate(agent->translate() + finalMove, true); // update entity position
					return deltaTime - stepDt * (step + 1.0f - scalar); // return overflow time
				}
			}

			// apply move
			pos += move;
			agent->set_translate(agent->translate() + move, true); // update entity position

			// update toTarget for next substep
			toTarget = agent->_target - pos;
		}

		return 0; // all time used
	}

} // namespace qk
